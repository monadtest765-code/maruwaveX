<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>MARU WAVE X â€“ 1bpsã®æ³¢ã‚’ä¹—ã‚Šã“ãªã›ï¼</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
      -webkit-user-select: none;
      user-select: none;
    }
    #gameCanvas {
      display: block;
    }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: white;
      text-align: center;
      pointer-events: auto;
      z-index: 50; 
    }
    
    /* ğŸŒŸ ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã®ã‚³ãƒ³ãƒ†ãƒŠã‚¹ã‚¿ã‚¤ãƒ« */
    #startMsg, #gameOverMsg {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: transparent;
        padding: 0;
        margin: 0;
        width: 100%;
        height: 100%;
    }
    
    /* ğŸŒŸ æ—¢å­˜ã®ãƒ†ã‚­ã‚¹ãƒˆè¦ç´ ã‚’éè¡¨ç¤ºåŒ– */
    #startMsg h1, #startMsg p, #gameOverMsg h1, #finalScore {
        display: none; 
    }
    
    /* ğŸŒŸ æ–°ã—ã„ç”»åƒãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠ */
    .image-button-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        position: relative;
        /* ã‚¹ã‚¿ãƒ¼ãƒˆç”»åƒã‚’ç”»é¢ã®ä¸­å¿ƒä»˜è¿‘ã«é…ç½®ã™ã‚‹ãŸã‚ã®èª¿æ•´ */
        top: -5vh; 
    }
    
    /* ************************************************************ */
    /* â˜…â˜…â˜… STARTãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« â˜…â˜…â˜… */
    /* ************************************************************ */

    #startImage {
        width: 100%;
        height: auto;
        display: block;
    }

    /* ğŸŒŸ æ±ç”¨ãƒœã‚¿ãƒ³ã¨ãƒ‡ãƒãƒƒã‚°ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #overlay button {
      font-size: 2.2vmin;
      padding: 0.5em 1.5em;
      border: none;
      border-radius: 8px;
      background: #00aaff;
      color: white;
      cursor: pointer;
      pointer-events: auto;
      margin: 5px; 
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 2.5em;
    }
    
    #overlay #debugButton {
      width: 50px;     /* â† æ¨ªå¹… */
      height: 40px;     /* â† é«˜ã• */
      font-size: 1.4vmin;  /* â† æ–‡å­—ã®å¤§ãã• */
      padding: 0;       /* â† å†…å´ã®ä½™ç™½ */
      /* display: none !important;  */ /* â˜… ãƒ‡ãƒãƒƒã‚°ã‚¹ã‚¤ãƒƒãƒ â˜… */
      opacity: 0;           /* å®Œå…¨é€æ˜ */
      pointer-events: auto; /* ã‚¯ãƒªãƒƒã‚¯ã¯é€šã™ */
      opacity: 0;            /* å®Œå…¨é€æ˜ */
      pointer-events: auto;  /* ã‚¯ãƒªãƒƒã‚¯ã¯é€šã™ */
      cursor: default;       /* â† ã‚«ãƒ¼ã‚½ãƒ«ã‚’æ™®é€šã®çŸ¢å°ã®ã¾ã¾ã«ã™ã‚‹ */
    }

    /* ğŸŒŸ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #gameOverImageContainer {
        position: relative; 
        width: 70vmin; 
        max-width: 400px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    #gameOverImage {
        width: 100%;
        height: auto;
        display: block;
        margin-bottom: 0px; 
    }

    /* ğŸŒŸ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢å†…ã®RETRY/TWEETãƒœã‚¿ãƒ³ã®é…ç½® */
    .gameOverButtonContainer {
        position: absolute;
        bottom: 9%;
        left: 50%;
        transform: translateX(-50%);
        width: 100%;
        height: 90px;
        pointer-events: none;
    }

    /* ************************************************************ */
    /* â˜…â˜…â˜… RETRY/TWEETãƒœã‚¿ãƒ³ã®ãƒ’ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹ â˜…â˜…â˜… */
    /* ************************************************************ */
    #restartButton {
        position: absolute;
        top: 0;
        left: calc(60% - 200px); 
        width: 140px; 
        height: 54px;
        background: transparent;
        border: none;
        padding: 0;
        margin: 0;
        min-height: 0;
        cursor: pointer;
        display: block;
        pointer-events: all;
    }

    #tweetButton {
        position: absolute;
        top: 0;
        left: calc(4% + 200px); 
        width: 140px; 
        height: 56px;
        background: transparent;
        border: none;
        padding: 0;
        margin: 0;
        min-height: 0;
        cursor: pointer;
        display: block;
        pointer-events: all;
        border-radius: 10px; 
    }

    
    /* ************************************************************ */
    /* â˜…â˜…â˜… ã‚¹ã‚³ã‚¢ãƒãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ« â˜…â˜…â˜… */
    /* ************************************************************ */
    
    /* 1. ã‚¹ã‚³ã‚¢ãƒãƒ¼å…¨ä½“ã®ã‚³ãƒ³ãƒ†ãƒŠã‚µã‚¤ã‚ºï¼ˆå¾®èª¿æ•´ãŒå¿…è¦ã§ã‚ã‚Œã°ã“ã“ã‚’èª¿æ•´ï¼‰ */
    #scoreBarContainer {
        position: absolute;
        bottom: 88vh;        /* ç”»é¢ä¸‹ã‹ã‚‰ã®è·é›¢ */
        left: 50%;
        transform: translateX(-50%);

        width: 30vmin;      /* ã‚ãªãŸã®ç”»åƒã«åˆã‚ã›ãŸæ¨ªå¹… */
        height: 12vmin;     /* é«˜ã•ï¼ˆç”»åƒã®ç¸¦æ¯”ã«åˆã‚ã›èª¿æ•´æ¸ˆã¿ï¼‰ */

        display: flex;
        justify-content: center;
        align-items: center;

        pointer-events: none; /* ã‚³ã‚¤ãƒ³ã‚„ã‚¸ãƒ£ãƒ³ãƒ—æ“ä½œã‚’é‚ªé­”ã•ã›ãªã„ */

        z-index: 20;
    }

    #scoreBarImage {
        width: 300%;
        height: 300%;
        object-fit: contain;
        display: block;
    }

    /* 2. ã‚²ãƒ¼ãƒ ãŒå‡ºåŠ›ã™ã‚‹æ•°å­—ã ã‘ã‚’é…ç½®ã—ã€å¾®èª¿æ•´ã‚’å®¹æ˜“ã«ã™ã‚‹ */

    #scoreDisplay {
        /* Star Coin (å·¦ç«¯) ã®ã‚¹ã‚³ã‚¢å€¤ */
        position: absolute;
        left: 14%; /* â† â˜… èª¿æ•´ãƒã‚¤ãƒ³ãƒˆ: Star Coin ã‚¢ã‚¤ã‚³ãƒ³ã®å³æ¨ªã«åˆã‚ã›ã‚‹ â˜… */
        color: white;
        font-size: 2.2vmin; /* â† â˜… èª¿æ•´ãƒã‚¤ãƒ³ãƒˆ: æ–‡å­—ã‚µã‚¤ã‚º â˜… */
        white-space: nowrap;
        transform: translateY(-50%);
        top: 50%; /* ã‚¹ã‚³ã‚¢ãƒãƒ¼ã®ç¸¦æ–¹å‘ä¸­å¤® */
    }

    #edgeCoinDisplay {
        /* EdgeXã‚¢ã‚¤ã‚³ãƒ³ (ä¸­å¤®) ã® X/10 */
        position: absolute;
        left: 45%; /* â† â˜… èª¿æ•´ãƒã‚¤ãƒ³ãƒˆ: EdgeXã‚¢ã‚¤ã‚³ãƒ³ã®å³æ¨ªã«åˆã‚ã›ã‚‹ â˜… */
        color: #00ff00; 
        font-size: 2.2vmin; /* â† â˜… èª¿æ•´ãƒã‚¤ãƒ³ãƒˆ: æ–‡å­—ã‚µã‚¤ã‚º â˜… */
        white-space: nowrap;
        transform: translateY(-50%);
        top: 50%; /* ã‚¹ã‚³ã‚¢ãƒãƒ¼ã®ç¸¦æ–¹å‘ä¸­å¤® */
    }

    #sealLifeDisplay {
        /* ãƒ©ã‚¤ãƒ•ã‚¢ã‚¤ã‚³ãƒ³ (å³ç«¯) ã®æ¨ªã® +X è¡¨ç¤º (ãƒœãƒ¼ãƒŠã‚¹ãƒ©ã‚¤ãƒ•ã®ã¿è¡¨ç¤º) */
        position: absolute;
        right: 13%; /* â† â˜… èª¿æ•´ãƒã‚¤ãƒ³ãƒˆ: æœ€å¾Œã®ãƒ©ã‚¤ãƒ•ã‚¢ã‚¤ã‚³ãƒ³ã®å³æ¨ªã«åˆã‚ã›ã‚‹ â˜… */
        color: white; 
        font-size: 2.2vmin; /* â† â˜… èª¿æ•´ãƒã‚¤ãƒ³ãƒˆ: æ–‡å­—ã‚µã‚¤ã‚º â˜… */
        display: block; 
        white-space: nowrap;
        transform: translateY(-50%);
        top: 50%; /* ã‚¹ã‚³ã‚¢ãƒãƒ¼ã®ç¸¦æ–¹å‘ä¸­å¤® */
        /* ãƒ©ã‚¤ãƒ•ãŒ3ä»¥ä¸‹ã®å ´åˆã€åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º */
        display: none; 
    }
    /* ************************************************************ */
    /* â˜…â˜…â˜… ã‚¹ã‚³ã‚¢ãƒãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ«çµ‚ã‚ã‚Š â˜…â˜…â˜… */
    /* ************************************************************ */

    
    #videoOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      display: none; 
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #videoPlayer {
      max-width: 90%;
      max-height: 90%;
    }
    #skipButton {
        position: absolute;
        bottom: 10%;
        right: 5%;
        font-size: 2vmin;
        padding: 10px 20px;
        background: #999;
        border-radius: 4px;
        z-index: 1001; 
    }
    
    /* STARTç”»åƒã®ã‚³ãƒ³ãƒ†ãƒŠ */
    #startImageContainer {
        position: relative;
        width: 70vmin;
        max-width: 500px;
        margin: 0 auto;
        display: flex;
        justify-content: center;
    }

    /* ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠ */
    .startButtonContainer {
        position: absolute;
        bottom: 3%;
        left: 50%;
        transform: translateX(-50%);
        width: 100%; 
        display: flex;
        justify-content: center;
    }

    /* STARTãƒœã‚¿ãƒ³ï¼ˆé€æ˜ãƒ’ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹ï¼‰ */
    #startButton {
        width: 150%; 
        height: 25vmin;
        cursor: pointer;
    }

    /* debug ãƒœã‚¿ãƒ³ã¯ STARTç”»åƒã®å¤–ã«é…ç½®ã™ã‚‹ */
    .debugSeparate {
        margin-top: 20px;
    }
    /* â˜… START / RETRY / TWEET ã¯å¼·åˆ¶ã§é€æ˜ã«ã™ã‚‹ */
    #startButton,
    #restartButton,
    #tweetButton {
        background: transparent !important;
        border: none !important;
    }


  

#scoreBar {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 40px;
    padding: 15px 40px;

    background: rgba(0, 0, 30, 0.4);
    border: 3px solid rgba(160,130,255,0.8);
    border-radius: 25px;
    z-index: 9999;
}

#scoreBar .icon {
    width: 48px;
    height: 48px;
}

#scoreBar span {
    font-size: 40px;
    color: #00ff00;
    font-weight: 900;
    text-shadow: 2px 2px 8px black;
}
/* ==== Play / Pause ãƒœã‚¿ãƒ³ ==== */
.pp-btn {
    width: 70px;
    height: 70px;
    border: 4px solid #fff;     /* â† ç™½ */
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;

    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 9999;
}

/* === Pause ãƒœã‚¿ãƒ³ä¸­å¤®æƒãˆï¼ˆæ­£ã—ã„ç‰ˆï¼‰ === */
#pauseButton.pp-btn {
    position: absolute;
    top: 20px;
    right: 20px;
}

/* â–¶ icon ä¸­å¤®é…ç½® */
#pauseButton .play,
#pauseButton .pause {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

/* pause ã®ç¸¦æ£’ã‚’ä¸­å¤®ã«å¯„ã›ã‚‹ */
#pauseButton .pause div {
    margin: 0 3px;
}



/* â–¶ Playï¼ˆä¸‰è§’ï¼‰ç™½ã‚¢ã‚¤ã‚³ãƒ³ */
.pp-btn .play {
    width: 0;
    height: 0;
    border-left: 28px solid #fff;      /* â† ç™½ã«å¤‰æ›´ */
    border-top: 18px solid transparent;
    border-bottom: 18px solid transparent;
}

/* â…¡ Pauseï¼ˆç¸¦æ£’2æœ¬ï¼‰ç™½ã‚¢ã‚¤ã‚³ãƒ³ */
.pp-btn .pause {
    display: flex;
    gap: 10px;
}

.pp-btn .pause div {
    width: 12px;
    height: 36px;
    background: #fff;                 /* â† ç™½ã«å¤‰æ›´ */
}
#pauseOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.4);
    color: white;
    font-size: 64px;
    font-weight: 900;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    display: none;
    pointer-events: none;
}

/* ===== ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°å°‚ç”¨ã‚¹ã‚¿ã‚¤ãƒ« ===== */

.endingText {
    font-family: 'Arial Black', sans-serif;
    font-size: 5vmin;
    font-weight: 900;
    letter-spacing: 1px;
    color: #fff;
    text-shadow:
        0 0 12px rgba(255,255,255,0.9),
        0 0 24px rgba(255,200,0,0.6),
        0 0 48px rgba(255,150,0,0.4);
}

.endingSub {
    font-family: 'Arial Black', sans-serif;
    font-size: 4vmin;
    font-weight: 800;
    color: #fff;
    margin-top: 10px;
    text-shadow:
        0 0 10px rgba(255,255,255,0.8),
        0 0 20px rgba(255,200,0,0.5);
}

.tweetBtn {
    margin-top: 30px;
    padding: 12px 32px;
    border: 3px solid #fff;
    border-radius: 16px;
    font-size: 3.5vmin;
    font-weight: bold;
    text-decoration: none;
    color: white;
    background: rgba(255,255,255,0.05);
    box-shadow:
        0 0 20px rgba(255,255,255,0.3),
        inset 0 0 10px rgba(255,255,255,0.3);
}
.tweetBtn:hover {
    background: rgba(255,255,255,0.2);
}


</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>


<div id="pauseButton" class="pp-btn">
    <div class="icon pause"><div></div><div></div></div>
</div>
<div id="pauseOverlay">PAUSED</div>



<!-- â˜… ã‚¹ã‚³ã‚¢ãƒãƒ¼ï¼ˆscore.pngï¼‰ã‚’å¾©æ´» â˜… -->
<div id="scoreBarContainer">
<img id="scoreBarImage" src="images/score.png">
</div>
<!-- â˜… ã“ã“ã¾ã§ â˜… -->



<div id="overlay">
  <div class="message" id="startMsg">
    
    <div id="startImageContainer">
        <img id="startImage" src="images/start.png" alt="ã‚¹ã‚¿ãƒ¼ãƒˆ">

        <div class="startButtonContainer">
            <button id="startButton"></button>
        </div>
    </div>

    <button id="debugButton" class="debugSeparate">ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
   


  </div> <div class="message" id="gameOverMsg" style="display:none;">
      <h1>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h1>
      <p id="finalScore"></p> 
      <div id="gameOverImageContainer">
          <img id="gameOverImage" src="images/gameover.png" alt="ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢">
          <div class="gameOverButtonContainer">
              <button id="restartButton"></button>
              <a id="tweetButton" href="#" target="_blank"></a>
          </div>
      </div>
  </div> <div class="message" id="pauseMsg" style="display:none;">
      <h1>WARNING! ãƒ€ãƒ¡ãƒ¼ã‚¸</h1>
      <p>æ®‹æ©ŸãŒæ¸›ã‚Šã¾ã—ãŸã€‚ç”»é¢ã®ã©ã“ã§ã‚‚ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ã‚¿ãƒƒãƒ—ã—ã¦å¾©å¸°ã—ã¦ãã ã•ã„ã€‚</p>
  </div>

  <div class="message" id="infoMsg" style="display:none;"></div>

</div>

<audio id="coinSound" src="sounds/se/coin.wav" preload="auto"></audio>
<audio id="hitSound" src="sounds/se/hit.wav" preload="auto"></audio>
<audio id="bgm" src="sounds/bgm/edgeX07.mp3" preload="auto" loop></audio>


<div id="videoOverlay">
  <video id="videoPlayer" preload="auto">
    ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯å‹•ç”»ã‚¿ã‚°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚
  </video>
  <button id="skipButton">SKIP</button>
</div>

<img id="edgecoinImg" src="images/edgecoin.png" style="display:none;">

<script>
const pauseBtn = document.getElementById("pauseButton");

// â˜… Pause ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸç¬é–“ã€mousedown ã‚’å®Œå…¨ã«æ­¢ã‚ã‚‹ï¼ˆæœ€é‡è¦ï¼‰
pauseBtn.addEventListener("mousedown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
});

pauseBtn.addEventListener("click", (e) => {
    ignoreNextJump = true;

    isGamePaused = !isGamePaused;

    if (isGamePaused) {
        pauseGame();
        pauseBtn.innerHTML = `<div class="icon play"></div>`;
    } else {
        resumeGame();
        pauseBtn.innerHTML = `
            <div class="icon pause"><div></div><div></div></div>
        `;
    }
});

// Canvas and context
const canvas = document.getElementById('gameCanvas');
const ctx = document.getElementById('gameCanvas').getContext('2d');

// Overlay elements
const overlay = document.getElementById('overlay');
const startMsg = document.getElementById('startMsg');
const gameOverMsg = document.getElementById('gameOverMsg');
const infoMsg = document.getElementById('infoMsg');
// ğŸŒŸ ä¿®æ­£: ç”»åƒãƒœã‚¿ãƒ³ã®IDã‚’ä½¿ç”¨
const debugButton = document.getElementById('debugButton'); 
const restartButton = document.getElementById('restartButton');
const tweetButton = document.getElementById('tweetButton');
const finalScoreElem = document.getElementById('finalScore');

const pauseMsg = document.getElementById('pauseMsg');
const skipButton = document.getElementById('skipButton');

const GOAL_COUNT = 10;

// ğŸŒŸ ç”»åƒè¦ç´ ã®å®šç¾©ã¨ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ã‚½ãƒ¼ã‚¹
const images = {};
const imageSources = {
    bgImg: 'images/background.png',
    maruImg: 'images/maru_new.png', 
    maruYarareImg: 'images/yarare01.png', 
    maruIdle1: 'images/maru_new.png', 
    maruIdle2: 'images/maru_idle2.png', 
    maruJumpImg: 'images/maru_jump.png', 
    edgecoinImg: 'images/edgecoin.png',
    shincoinSheet: 'images/shincoin2.png',
    startImg: 'images/start.png',
    nanazugaraImg: 'images/nanazugara.png',
    gameOverImgFile: 'images/gameover.png', 
    // ä¿®æ­£: sealLifeImg ã¯ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ç”»åƒã¨ã—ã¦ã¯æ®‹ã™ãŒã€ã‚²ãƒ¼ãƒ å†…ã§ã®å‹•çš„è¡¨ç¤ºã¯ã—ãªã„
    
};

for (const key in imageSources) {
    images[key] = new Image();
    images[key].src = imageSources[key];
}

const maruIdleFrames = [images.maruIdle1, images.maruIdle2];
const edgecoinImg = images.edgecoinImg;
const shincoinImg = images.shincoinImg; 
let idleFrameIndex = 0;
let lastIdleSwitch = 0;
const idleFrameInterval = 200; 

// Audio and Video elements
const bgm = document.getElementById('bgm');
const coinSound = document.getElementById('coinSound');
const hitSound = document.getElementById('hitSound');
const videoOverlay = document.getElementById('videoOverlay');
const videoPlayer = document.getElementById('videoPlayer');
const nanaSound = new Audio("sounds/se/nanaon.mp3");
nanaSound.volume = 1.0;



// Audio Context setup
let audioCtx = null;
let analyser = null;
let frequencyData = null;

// Game variables
let gameState = 'start'; 
let maru = { x: 0, y: 0, radius: 0, vy: 0, currentImage: images.maruIdle1 }; 
const FPS = 60;
const FRAME_TIME = 1000 / FPS;
const GRAVITY = 0.3;
const JUMP = -7;
let obstacles = [];
let spawnInterval = 2500;
let lastSpawn = 0;
let coins = []; 
let ignoreNextJump = false;   // â† è¿½åŠ 



let coinSpawnInterval = 1500; 
let lastCoinSpawn = 0;
let score = 0;
let bestScore = 0;
let messages = [
  {threshold: 30, text: 'edgeX is a high-performance order book perpetual futures exchange incubated by Amber Group in 2023.'},
  {threshold: 60, text: 'edgeX is a high-performance decentralized perpetual futures exchange (Perp DEX) utilizing Ethereum Layer 2 technology.'},
  {threshold: 120, text: 'It allows trading on both web and mobile, and features sub-accounts and cross-chain capabilities.'},
  {threshold: 150, text: 'Although the token is not yet issued, the community is highly active ahead of the TGE (Token Generation Event).'},
  {threshold: 180, text: 'Deep liquidity and low-latency order book matching provide a CEX (Centralized Exchange)-like experience.'},
  {threshold: 210, text: 'edgeXâ€™s roadmap aims to build its own proprietary Layer 2 chain and expand its on-chain trading products.'},
  {threshold: 240, text: 'edgeX adopts StarkWareâ€™s zk-rollup technology to enable fast and low-cost on-chain settlement.'},
  {threshold: 270, text: 'edgeX has the #1 fee revenue among all chains that have not yet issued a token.'},
  {threshold: 300, text: 'edgeX is the next-generation strongest PERP DEX, in short, it is "God".'}
];
let nextMessageIndex = 0;

let isDebugMode = false;
let isGamePaused = false;  // â˜… ã‚²ãƒ¼ãƒ ãŒä¸€æ™‚åœæ­¢ä¸­ã‹ã©ã†ã‹
let isInvincible = false;
let invincibilityEndTime = 0;
const INVINCIBILITY_DURATION = 2500;

let lives = 3; 
const MAX_LIVES = 3; 
let totalRegularCoinsCollected = 0; 
const COINS_PER_LIFE = 100; 

let edgeCoinCollectedCount = 0; 
let last9thCoinCollectedTime = null; 
const COIN_10_TRIGGER_TIME = 100000; 

let pendingEdgeBonus = false;        // EdgeCoin ã®å‹•ç”»çµ‚äº†å¾Œã®ä»˜ä¸
let pendingNanaBonus = null;         // NanaCoin ã®å‹•ç”»çµ‚äº†å¾Œã®ä»˜ä¸å†…å®¹


// â˜… EdgeCoin 10æšç›®ç”¨ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³å¤‰æ•°
let edgeCountdown = 0;
let edgeCountdownEndTime = null;

// â­ ã€è¿½åŠ ã€‘EdgeCoin 100% å‡ºç¾ãƒ‡ãƒãƒƒã‚°ã‚¹ã‚¤ãƒƒãƒ
let forceEdgeCoin100 = false;


let hasStarted = false;
const BASE_SPEED_PER_WIDTH = 0.002;
const SPEED_SCALE_TIME = 15000;
let gameStartTime = null;
let stars = [];

let currentVideoQueue = []; 
let videoPauseTime = 0; 
let shincoinFrameIndex = 0;
let shincoinFrameTimer = 0;
const shincoinFrameCount = 8;




// ---------------------------------------------------------------------------
// ğŸ¨âœ¨ Added variables for rich effects
// ---------------------------------------------------------------------------
// Score pop animation
let scorePopScale = 1;
let scorePopTarget = 1;
let scorePopSpeed = 0.15;
// Score combo tracking
let lastScoreUpdateTime = 0;
let scoreStreakCount = 0;
let rainbowEffectEnd = 0;
// EdgeCoin flash for central counter
let edgeCoinFlashEnd = 0;
// Life shake animation
let lifeShakeEnd = 0;
let lifeShakeAmplitude = 0;
// Maru flash effect
let maruFlashEnd = 0;
// Afterimage storage
let afterimages = [];
// Particle effects storage
let particles = [];
// Star brightness flash
let starFlashEnd = 0;

// Utility and Resize functions (å‰å›ã®ã‚³ãƒ¼ãƒ‰ã¨åŒä¸€ã§ã™)
function lightenColor(hex, factor) { 
  const col = parseInt(hex.replace('#', ''), 16);
  let r = (col >> 16) & 0xff;
  let g = (col >> 8) & 0xff;
  let b = col & 0xff;
  r = Math.round(r + (255 - r) * factor);
  g = Math.round(g + (255 - g) * factor);
  b = Math.round(b + (255 - b) * factor);
  const newCol = (1 << 24) | (r << 16) | (g << 8) | b;
  return '#' + newCol.toString(16).slice(1);
}
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  initStars();
  maru.radius = canvas.height * 0.05;
  maru.x = canvas.width * 0.2;
  if (gameState === 'start' || gameState === 'gameover' || gameState === 'paused_after_hit') {
    maru.y = canvas.height / 2;
  }
  if (gameState === 'start') {
     drawBackground(performance.now());
     drawMaru(performance.now());
  }
}
window.addEventListener('resize', resize);
resize();

// ğŸŒŸ ä¿®æ­£: ãƒ©ã‚¤ãƒ•è¡¨ç¤ºã‚’æ•°å­—ï¼ˆ+Xï¼‰ã®ã¿ã«å¤‰æ›´
function updateLivesDisplay() {
  // lives > MAX_LIVES (3) ã®å ´åˆã®ã¿ã€ã€Œ+Xã€ã¨ã„ã†å½¢ã§ãƒœãƒ¼ãƒŠã‚¹ãƒ©ã‚¤ãƒ•ã‚’è¡¨ç¤º
  if (lives > MAX_LIVES) {
     
  } else {
      // ãƒ©ã‚¤ãƒ•ãŒ3ä»¥ä¸‹ã®å ´åˆã€score.pngå†…ã®ã‚¢ã‚¤ã‚³ãƒ³ã«ä»»ã›ã‚‹ãŸã‚ã€æ•°å­—ã¯éè¡¨ç¤º
      
  }
}

// ğŸŒŸ ä¿®æ­£: EdgeCoinè¡¨ç¤ºã®æ›´æ–°ï¼ˆæ–°ã—ã„IDã‚’ä½¿ç”¨ï¼‰
function updateEdgeCoinDisplay() {
    
}

function resumeGameFromVideo() {

pauseBtn.style.display = "block";

    console.log("=== resumeGameFromVideo èµ·å‹• ===");

    if (edgeCoinCollectedCount === GOAL_COUNT) {
        startEndingSequence();
        return;
 }



    console.log("=== resumeGameFromVideo èµ·å‹• ===");
    console.log("pendingEdgeBonus:", pendingEdgeBonus);
    console.log("edgeCoinCollectedCount:", edgeCoinCollectedCount);


        
    // â˜… ã¾ã å†ç”Ÿã™ã¹ãå‹•ç”»ã‚­ãƒ¥ãƒ¼ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆ
    if (currentVideoQueue.length > 0) {
        const nextVideo = currentVideoQueue.shift();
        playVideo(nextVideo);
        return;
    }
    
    // â˜… å‹•ç”»çµ‚äº†å¾Œã®å¾Œå‡¦ç†
    videoPlayer.onended = null;
    videoOverlay.style.display = 'none';
    gameState = 'playing';

    // ------------------------------------------------------
    // â˜…â˜…â˜…â˜…â˜… EdgeCoin ã®å¾Œä»˜ã‘ä»˜ä¸ï¼ˆå‹•ç”»çµ‚äº†å¾Œã«åæ˜ ï¼‰ â˜…â˜…â˜…â˜…â˜…
    // ------------------------------------------------------
    if (pendingEdgeBonus) {

        edgeCoinCollectedCount++;
        updateEdgeCoinDisplay();

        // ãƒ©ã‚¤ãƒ• +1
        if (lives < MAX_LIVES + 10) {
            lives += 1;
            updateLivesDisplay();
        }

        // 9æšç›® â†’ ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³é–‹å§‹
        if (edgeCoinCollectedCount === 9) {
            last9thCoinCollectedTime = performance.now();
            edgeCountdownEndTime =
                last9thCoinCollectedTime + COIN_10_TRIGGER_TIME;
        }

        // 10æšç›® â†’ ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
if (edgeCoinCollectedCount === GOAL_COUNT) {

    gameState = 'ending_trigger';

    if (bgm) {
        bgm.pause();
        bgm.currentTime = 0;
    }

    // â˜…â˜…â˜… å…ˆã«ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã¸ â˜…â˜…â˜…
    startEndingSequence();

    // â˜…â˜…â˜… ã“ã“ã§åˆã‚ã¦ pendingEdgeBonus ã‚’è§£é™¤ â˜…â˜…â˜…
    pendingEdgeBonus = false;

    return;
}
}


    // ------------------------------------------------------
    // â˜…â˜…â˜…â˜…â˜… NanaCoin ã®å¾Œä»˜ã‘ä»˜ä¸ï¼ˆå‹•ç”»çµ‚äº†å¾Œã«åæ˜ ï¼‰ â˜…â˜…â˜…â˜…â˜…
    // ------------------------------------------------------
    if (pendingNanaBonus) {

        // å¤§é‡ãƒ©ã‚¤ãƒ•ä»˜ä¸
        lives += pendingNanaBonus.life;
        updateLivesDisplay();

        // coinzoroi ã®å ´åˆã¯ EdgeCoin æ‰±ã„
        if (pendingNanaBonus.isEdge) {
            edgeCoinCollectedCount++;
            updateEdgeCoinDisplay();
        }

        pendingNanaBonus = null;
    }



    
    // â˜… å‹•ç”»ä¸­ã®çµŒéæ™‚é–“ã‚’ã‚²ãƒ¼ãƒ ã‚¿ã‚¤ãƒãƒ¼ã¸åæ˜ 
    const videoDuration = performance.now() - videoPauseTime;
    if (gameStartTime !== null) {
        gameStartTime += videoDuration;
    }
    
    // â˜… ç„¡æ•µæ™‚é–“ã‚’ä»˜ä¸
    isInvincible = true;
    invincibilityEndTime = performance.now() + INVINCIBILITY_DURATION;

    // ------------------------------------------------------
    // ğŸ”¥ã€ã“ã“ãŒæœ€å¤§ã®ä¿®æ­£ç‚¹ã€‘ BGM ã‚’ç¢ºå®Ÿã«å¾©å¸°ã•ã›ã‚‹
    // ------------------------------------------------------
    try {
        if (bgm) {
            // BGM ã®ç¾åœ¨ä½ç½®ãŒ NaN / undefined ã®å ´åˆé˜²æ­¢
            if (isNaN(bgm.currentTime)) {
                bgm.currentTime = 0;
            }
            // éŸ³é‡ã‚’é©æ­£ã«æˆ»ã™
            bgm.volume = 0.6;

            // file:// ã§ã‚‚ localhost ã§ã‚‚ GitHub Pages ã§ã‚‚å…¨éƒ¨å†ç”Ÿã•ã‚Œã‚‹
            bgm.play().catch(err => {
                console.warn("BGM resume blocked:", err);
            });
        }
    } catch (err) {
        console.warn("BGM resume fatal error:", err);
    }

    // â˜… ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—å¾©å¸°
    lastTimestamp = performance.now();
    if (animFrameId === null) {
        animFrameId = window.requestAnimationFrame(gameLoop);
    }
}

// ------------------------------------------------------
// â˜…â˜…â˜… ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°å°‚ç”¨ï¼šå‹•ç”»ã‚’å³å†ç”Ÿã™ã‚‹é–¢æ•° â˜…â˜…â˜…
// ------------------------------------------------------
function playVideoDirect(src) {
    videoPlayer.src = src;

    // â˜… ä¸­å¤®é…ç½®ï¼ˆé€šå¸¸ãƒ ãƒ¼ãƒ“ãƒ¼ã¨åŒã˜ä½ç½®ã¸å¼·åˆ¶ï¼‰
    videoOverlay.style.display = 'block';
    videoPlayer.style.display = 'block';

    // ä½ç½®ã‚’å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆï¼ˆCSSä¸Šæ›¸ãï¼‰
    videoPlayer.style.position = "absolute";
    videoPlayer.style.left = "50%";
    videoPlayer.style.top = "50%";
    videoPlayer.style.transform = "translate(-50%, -50%)";
    videoPlayer.style.width = "80%";
    videoPlayer.style.height = "auto";

    videoPlayer.play();
}

function playVideo(videoFileName) {
videoPlayer.onplay = () => {
    pauseBtn.style.display = "none";
};

  videoPlayer.innerHTML = `<source src="movies/${videoFileName}" type="video/mp4">`;
  videoPlayer.load(); 
  

  // â˜… å…ƒã® SKIP åˆ¤å®šï¼ˆplus1.mp4 ã¯ SKIPç¦æ­¢ï¼‰
  if (videoFileName === 'end.mp4') {
      skipButton.style.display = 'none';
  } else {
      skipButton.style.display = 'block';
  }

  // â˜… ãƒŠãƒŠå›³æŸ„å‹•ç”»ã¯ SKIPç¦æ­¢
  const nanaVideos = [
    'coinzoroi.mp4',
    'maruhazure.mp4',
    'maruzoroi01.mp4',
    'maruzoroi02.mp4',
    'maruzoroi03.mp4',
    'nanazoroi.mp4',
    'fleeze.mp4'
  ];
  if (nanaVideos.includes(videoFileName)) {
    skipButton.style.display = 'none';
  }

  if (animFrameId !== null) {
    cancelAnimationFrame(animFrameId);
    animFrameId = null;
  }  
  if (bgm) {
    bgm.pause();
  }

  videoPauseTime = performance.now();
  
  gameState = 'video';
  videoOverlay.style.display = 'flex';
  videoPlayer.currentTime = 0; 
  videoPlayer.play().catch(e => console.error(`Video (${videoFileName}) play failed:`, e));

  videoPlayer.onended = () => {
    resumeGameFromVideo(); 
  };
}

function skipVideo() {
    if (gameState === 'video') {
        videoPlayer.pause(); 
        resumeGameFromVideo(); 
    }
}

function jump() {

  // â˜… ã¾ãš Pause ä¸­ã¯çµ¶å¯¾ã«ã‚¸ãƒ£ãƒ³ãƒ—ç„¡åŠ¹
  if (isGamePaused) return;

  // â˜… Pauseãƒœã‚¿ãƒ³ç›´å¾Œã®ã‚¸ãƒ£ãƒ³ãƒ—èª¤ä½œå‹•ã‚’1å›ã ã‘ç„¡è¦–
  if (ignoreNextJump) {
      ignoreNextJump = false;
      return;
  }

  // â˜… å…ƒã€…ã®ã‚¸ãƒ£ãƒ³ãƒ—ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’ãã®ã¾ã¾ï¼‰
  if (gameState === 'playing') {
      if (!hasStarted) {
        hasStarted = true;
        maru.vy = JUMP;
        gameStartTime = performance.now();
        
        if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume().catch(e => console.error("AudioContext resume failed on first jump:", e));
        }
      } else {
        maru.vy = JUMP;
      }

      spawnAfterimages();
  }
}
// â˜…â˜…â˜… ã‚²ãƒ¼ãƒ ä¸€æ™‚åœæ­¢å‡¦ç† â˜…â˜…â˜…
function pauseGame() {
    isGamePaused = true;

    // æç”»ãƒ«ãƒ¼ãƒ—ã‚’æ­¢ã‚ã‚‹
    if (animFrameId !== null) {
        cancelAnimationFrame(animFrameId);
        animFrameId = null;
    }

    // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¡¨ç¤º
    const overlay = document.getElementById("pauseOverlay");
    overlay.style.display = "flex";
}

function resumeGame() {
    lastTimestamp = performance.now();
    isGamePaused = false;

    const overlay = document.getElementById("pauseOverlay");
    overlay.style.display = "none";

    // ãƒ«ãƒ¼ãƒ—å†é–‹
    animFrameId = requestAnimationFrame(gameLoop);
}



function initGame(debug = false) {
  isDebugMode = debug; 
  
  gameState = 'playing';
  lastTimestamp = null;
  maru.radius = canvas.height * 0.05;
  maru.x = canvas.width * 0.2;
  maru.y = canvas.height / 2;
  maru.vy = 0;
  maru.currentImage = images.maruIdle1; 
  obstacles = [];
  lastSpawn = 0;
  coins = [];
  lastCoinSpawn = 0;
  score = 0;
  nextMessageIndex = 0;
  hasStarted = false;
  
  lives = MAX_LIVES; 
  totalRegularCoinsCollected = 0;
  isInvincible = false; 
  invincibilityEndTime = 0;
  
  edgeCoinCollectedCount = 0; 
  last9thCoinCollectedTime = null; 
  updateEdgeCoinDisplay(); 
  
  currentVideoQueue = []; 
  
  infoMsg.style.display = 'none';
  startMsg.style.display = 'none';
  gameOverMsg.style.display = 'none';
  pauseMsg.style.display = 'none'; 
  overlay.style.pointerEvents = 'none';
  
  updateLivesDisplay();
  
  const isFileProtocol = window.location.protocol === 'file:' || window.location.protocol === '';
  if (bgm) {
   bgm.currentTime = 0;
   bgm.volume = 0.6;
   const playPromise = bgm.play();
   if (playPromise !== undefined) {
     playPromise
       .then(() => console.log("ğŸµ BGM started"))
       .catch(err => console.warn("BGM play blocked (will retry on user gesture):", err));
  }
}

  setupAudio();
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(e => console.error("AudioContext resume failed in initGame:", e));
  }
  
  animFrameId = window.requestAnimationFrame(gameLoop);
  initStars();
}

function spawnObstacle() {
  const gapHeight = canvas.height * 0.36;
  const minGapY = canvas.height * 0.2;
  const maxGapY = canvas.height - gapHeight - canvas.height * 0.2;
  const gapY = minGapY + Math.random() * (maxGapY - minGapY);
  const width = canvas.width * 0.12;
  const amplitude = canvas.height * (0.05 + Math.random() * 0.05);
  const phase = Math.random() * Math.PI * 2;
  const wickTopRatio = 0.05 + Math.random() * 0.15;
  const wickBottomRatio = 0.05 + Math.random() * 0.15;
  const topWickColor = lightenColor('#e44a4a', 0.4);
  // Fix typo in color code (missing digit) so that lightenColor processes a valid 6â€‘digit hex.
  const bottomWickColor = lightenColor('#2ca24c', 0.4);

  obstacles.push({
    x: canvas.width + width,
    width,
    baseGapY: gapY,
    gapHeight,
    amplitude,
    phase,
    passed: false,
    wickTopRatio,
    wickBottomRatio,
    topWickColor,
    bottomWickColor
  });
}

function spawnCoin() {
  const coinRadius = maru.radius * 0.8;

  let isEdgeCoin = false;
  let isNanaCoin = false;

  let probability = 0;
  const count = edgeCoinCollectedCount;

  // â˜…â˜…â˜…â˜…â˜… ã¾ãšæœ€åˆã«ã€Œç¾åœ¨ã®ãƒŠãƒŠå›³æŸ„æ•°ã€ã‚’ç¢ºå®šå–å¾—ã™ã‚‹ â˜…â˜…â˜…â˜…â˜…
  const nanaCountOnScreen = coins.filter(
      c => c.isNanaCoin && !c.collected
  ).length;
  // â˜…â˜…â˜…â˜…â˜… ã“ã“ã¾ã§ï¼ˆã“ã‚Œã«ã‚ˆã‚Šåˆ¤å®šãŒã‚ºãƒ¬ãªã„ï¼‰ â˜…â˜…â˜…â˜…â˜…

  const edgeCoinOnScreen = coins.some(
      coin => coin.isEdgeCoin && !coin.collected
  );

  if (count < GOAL_COUNT && !edgeCoinOnScreen) {

      if (forceEdgeCoin100) {
          probability = 1.0;

      } else if (count === 9) {
          const timeElapsed = performance.now() - last9thCoinCollectedTime;
          if (last9thCoinCollectedTime !== null && timeElapsed >= COIN_10_TRIGGER_TIME) {
              probability = 1.0;
          } else {
              probability = 0.0;
          }

      } else if (count === 0) {
          probability = 1.0;

      } else if (count === 1) {
          probability = 0.50;

      } else if (count === 2 || count === 3) {
          probability = 0.30;

      } else if (count === 4) {
          probability = 0.20;

      } else if (count === 5) {
          probability = 0.15;

      } else if (count === 6) {
          probability = 0.50;

      } else if (count === 7) {
          probability = 0.15;

      } else if (count === 8) {
          probability = 0.10;
      }

      isEdgeCoin = Math.random() < probability;
  }

  // â˜…â˜…â˜…â˜…â˜… ãƒŠãƒŠå›³æŸ„æŠ½é¸ï¼šä¸Šé™ 2 å€‹ä»¥ä¸‹ã®ã¨ãã®ã¿ â˜…â˜…â˜…â˜…â˜…
  if (!isEdgeCoin && nanaCountOnScreen < 2) {

      if (edgeCoinCollectedCount <= 6) {

          if (Math.random() < 0.07) {
              isNanaCoin = true;
          }

      }
  }
  // â˜…â˜…â˜…â˜…â˜… ã“ã“ã¾ã§çµ¶å¯¾ã«3å€‹ä»¥ä¸Šã«å¢—ãˆãªã„ â˜…â˜…â˜…â˜…â˜…


  const minY = coinRadius * 2;
  const maxY = canvas.height - coinRadius * 2;
  const coinY = minY + Math.random() * (maxY - minY);
  const coinX = canvas.width + coinRadius;
  
  coins.push({
    x: coinX,
    y: coinY,
    radius: coinRadius,
    size: coinRadius * 2,
    rotation: 0,
    isEdgeCoin: isEdgeCoin,
    isNanaCoin: isNanaCoin,
    collected: false
  });
}


function updateCoins(delta) {

  
  if (!hasStarted) return;
  
  // === ShinCoin ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–° ===
  shincoinFrameTimer += delta;
  if (shincoinFrameTimer >= 100) {   // 100msã”ã¨ã«1ãƒ•ãƒ¬ãƒ¼ãƒ é€²ã‚€
    shincoinFrameIndex = (shincoinFrameIndex + 1) % shincoinFrameCount;
    shincoinFrameTimer = 0;
  }




  const dt = delta / FRAME_TIME;
  
  const timeElapsed = gameStartTime === null ? 0 : performance.now() - gameStartTime;
  const speedScale = Math.min(1.0, timeElapsed / SPEED_SCALE_TIME);
  const currentSpeed = canvas.width * (BASE_SPEED_PER_WIDTH + BASE_SPEED_PER_WIDTH * speedScale);
  
  for (let i = coins.length - 1; i >= 0; i--) {
    const coin = coins[i];
    coin.x -= currentSpeed * dt;
    
    if (coin.x + coin.radius < 0) {
      coins.splice(i, 1);
    }
  }
  
  if (performance.now() - lastCoinSpawn > coinSpawnInterval) {
    // EdgeCoin 100%ã‚¹ã‚¤ãƒƒãƒãŒONã®å ´åˆã€EdgeCoinå‡ºç¾ä¸­ã¯é€šå¸¸ã‚³ã‚¤ãƒ³ã‚’ã‚¹ãƒãƒ¼ãƒ³ã•ã›ãªã„
    const edgeCoinOnScreen = coins.some(coin => coin.isEdgeCoin && !coin.collected);
    if (!forceEdgeCoin100 || !edgeCoinOnScreen) {
        if (Math.random() < 0.6) {
          spawnCoin();
        }
    }
    lastCoinSpawn = performance.now();
  }
}

// === EdgeCoin EQ Animation params ===
let edgePulseStrength = 0;
let edgeHaloStrength = 0;



function drawCoins(delta) {
    for (let coin of coins) {

        // === EQ ãƒ‘ãƒ«ã‚¹è¨ˆç®— ===
        let pulse = 1;
        let halo = 0;

        if (coin.isEdgeCoin && analyser && frequencyData) {
            analyser.getByteFrequencyData(frequencyData);

            const v1 = frequencyData[5] || 0;
            const v2 = frequencyData[6] || 0;
            const v3 = frequencyData[7] || 0;
            const volume = (v1 + v2 + v3) / 3;

            // è„ˆå‹•ï¼ˆ0.9ã€œ1.3ï¼‰
            pulse = 0.9 + (volume / 255) * 0.40;

            // ç™ºå…‰å¼·åº¦ï¼ˆ0ã€œ1ï¼‰
            halo = volume / 255;
        }

        const baseSize = coin.radius * 3;
        const size = baseSize * pulse;

        ctx.save();
        ctx.translate(coin.x, coin.y);

        // ============================
        // â­ NanaCoinï¼ˆãƒŠãƒŠå›³æŸ„ï¼‰
        // ============================
        if (coin.isNanaCoin) {

            // â˜… ãƒ‘ãƒ«ã‚¹ç™ºå…‰ï¼ˆéŸ³é€£å‹•ã¯ã•ã›ãšã€è¦‹ãŸç›®å®‰å®šï¼‰
            const t = performance.now() / 250;
            const pulseGlow = (Math.sin(t) + 1) / 2; // 0ã€œ1
            const glow = 25 + pulseGlow * 25;       // 25ã€œ50

            ctx.shadowBlur = glow;
            ctx.shadowColor = "rgba(255, 80, 200, 0.95)"; // ãƒ”ãƒ³ã‚¯å¼·ã‚ã®ãƒã‚ªãƒ³

            ctx.drawImage(
                images.nanazugaraImg,
                -baseSize / 2,
                -baseSize / 2,
                baseSize,
                baseSize
            );

            // ãƒªã‚»ãƒƒãƒˆ
            ctx.shadowBlur = 0;
            ctx.shadowColor = "transparent";

            ctx.restore();
            continue;
        }

        // ============================
        // â­ EdgeCoin å°‚ç”¨æç”»ï¼ˆæ—¢å­˜ï¼‰
        // ============================
        if (coin.isEdgeCoin) {

            ctx.drawImage(
                images.edgecoinImg,
                -size / 2,
                -size / 2,
                size,
                size
            );

            if (halo > 0.05) {
                const maxR = size * (0.5 + halo * 0.5);
                const grd = ctx.createRadialGradient(
                    0, 0, size * 0.5,
                    0, 0, maxR
                );

                grd.addColorStop(0.0, `rgba(${100 + halo * 155}, ${80}, 255, ${0.35 * halo})`);
                grd.addColorStop(0.4, `rgba(180, 80, 255, ${0.30 * halo})`);
                grd.addColorStop(0.7, `rgba(255, 80, 200, ${0.25 * halo})`);
                grd.addColorStop(1.0, `rgba(255,255,255,${0.20 * halo})`);

                ctx.globalAlpha = 0.9 * halo;
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(0, 0, maxR, 0, Math.PI * 2);
                ctx.fill();
            }

        } else {

            // ============================
            // â­ é€šå¸¸ ShinCoinï¼ˆæ—¢å­˜ï¼‰
            // ============================
            const sheet = images.shincoinSheet;
            const frameHeight = sheet.height / shincoinFrameCount;
            const sy = frameHeight * shincoinFrameIndex;

            ctx.drawImage(
                sheet,
                0, sy,
                sheet.width, frameHeight,
                -coin.radius * pulse,
                -coin.radius * pulse,
                size,
                size
            );
        }

        ctx.restore();
    }
}
   

function checkCoinCollision() {
    for (let i = coins.length - 1; i >= 0; i--) {
        const coin = coins[i];
        if (coin.collected) continue;

        const dx = maru.x - coin.x;
        const dy = maru.y - coin.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < maru.radius + coin.radius) {

            // =====================================================
            // â˜…â˜…â˜… NanaCoinï¼ˆãƒŠãƒŠå›³æŸ„ï¼‰å°‚ç”¨ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆä»˜ä¸ã¯å¾Œã§ï¼‰ â˜…â˜…â˜…
            // =====================================================
           if (coin.isNanaCoin) {

    // â˜… ãƒŠãƒŠå°‚ç”¨SEï¼ˆã“ã“ã§é³´ã‚‰ã™ï¼‰
    nanaSound.currentTime = 0;
    nanaSound.play();

                let r = Math.random();
                let video = null;
                let lifeUp = 0;

                if (r < 0.50) {
                    video = 'coinzoroi.mp4';
                    lifeUp = 1;
                } else if (r < 0.74) {
                    video = 'maruhazure.mp4';
                    lifeUp = 1;
                } else if (r < 0.82) {
                    video = 'maruzoroi01.mp4';
                    lifeUp = 3;
                } else if (r < 0.90) {
                    video = 'maruzoroi02.mp4';
                    lifeUp = 3;
                } else if (r < 0.98) {
                    video = 'maruzoroi03.mp4';
                    lifeUp = 3;
                } else if (r < 0.99) {
                    video = 'nanazoroi.mp4';
                    lifeUp = 7;
                } else {
                    video = 'fleeze.mp4';
                    lifeUp = 7;
                }

                // â˜… ã“ã“ã§ã¯ä»˜ä¸ã—ãªã„ â†’ å‹•ç”»çµ‚äº†å¾Œã«ä»˜ä¸ã™ã‚‹
                pendingNanaBonus = {
                    life: lifeUp,
                    isEdge: (video === 'coinzoroi.mp4')
                };

                currentVideoQueue = [];
                playVideo(video);

                coin.collected = true;
                coins.splice(i, 1);
                return;
            }

            // ============================
            // â˜… é€šå¸¸ã® EdgeCoinï¼ˆä»˜ä¸ã¯å¾Œã§ï¼‰
            // ============================
            coin.collected = true;
            coinSound.currentTime = 0;
            coinSound.play();

            if (coin.isEdgeCoin) {

    // â˜… å–ã£ãŸç¬é–“ã®ä»˜ä¸ã‚’ç¦æ­¢ â†’ å‹•ç”»å¾Œã«åæ˜ 
    pendingEdgeBonus = true;

    let videoFile;
    let nextVideoFile = null;

    // ---- 10æšç›®ã®ç›´å‰ã¾ã§ã®å‹•ç”»é¸æŠãƒ­ã‚¸ãƒƒã‚¯ ----
    if (edgeCoinCollectedCount === 0) {
        videoFile = '01.mp4';
    } else if (edgeCoinCollectedCount === 1) {
        videoFile = '02.mp4';
    } else if (edgeCoinCollectedCount === 2) {
        videoFile = '03.mp4';
    } else {
        const movies = [
            '01.mp4','02.mp4','03.mp4','04.mp4',
            '05.mp4','06.mp4','07.mp4','08.mp4',
            '09.mp4','10.mp4','11.mp4','12.mp4'
        ];
        const randomIndex = Math.floor(Math.random() * movies.length);
        videoFile = movies[randomIndex];
    }

     // ------------------------------------------------------------
        // â˜…â˜…â˜…ã€æœ€é©è§£ã€‘10æšç›®ã¯å‹•ç”»ã‚’å†ç”Ÿã—ãªã„ï¼†å³ã‚«ã‚¦ãƒ³ãƒˆã‚¢ãƒƒãƒ— â˜…â˜…â˜…
        // ------------------------------------------------------------
        if (edgeCoinCollectedCount === 9) {

            edgeCoinCollectedCount++;
            updateEdgeCoinDisplay();

            coins.splice(i, 1);

            console.log("â˜… 10æšç›®ï¼šå³ã‚«ã‚¦ãƒ³ãƒˆ â†’ ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã¸ â˜…");
            gameState = 'ending_trigger';

            if (bgm) {
                bgm.pause();
                bgm.currentTime = 0;
            }

            startEndingSequence();
            return;
        }

    // ------------------------------------------------------------
    // â˜…â˜…â˜… é€šå¸¸ã® 1ã€œ9 æšç›®ã¯å‹•ç”»å†ç”Ÿ â˜…â˜…â˜…
    // ------------------------------------------------------------
    currentVideoQueue = [];
    if (nextVideoFile) currentVideoQueue.push(nextVideoFile);

    playVideo(videoFile);
    triggerEdgeCoinEffects(coin.x, coin.y);

} else {
    // â­ é€šå¸¸ã‚³ã‚¤ãƒ³ï¼ˆå¾“æ¥é€šã‚Šï¼‰
    score += 10;
    totalRegularCoinsCollected += 1;
    triggerScoreIncrease(10, coin.x, coin.y);

    if (lives < MAX_LIVES + 10 && totalRegularCoinsCollected >= COINS_PER_LIFE) {
        totalRegularCoinsCollected -= COINS_PER_LIFE;
        lives += 1;
        updateLivesDisplay();
        showInfo('ã‚³ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹ï¼+1 Life');
    }
}

// æœ€å¾Œã«ã‚³ã‚¤ãƒ³å‰Šé™¤ï¼ˆå‹•ç”»å†ç”Ÿã—ãªã„ã¨ãã¯ä¸Šã§å‰Šé™¤æ¸ˆï¼‰
coins.splice(i, 1);
        }  // â† dist < ã®é–‰ã˜
    }      // â† for ã®é–‰ã˜
}          // â† é–¢æ•°ã®é–‰ã˜


function drawScoreBoard() {
    const bar = document.getElementById("scoreBarContainer");
    const rect = bar.getBoundingClientRect();
    const now = performance.now();

    ctx.save();
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";

    // Base font size and weight
    const baseFontSize = canvas.height * 0.033;
    ctx.font = `900 ${baseFontSize}px Arial`;

    // Smoothly interpolate pop scale
    scorePopScale += (scorePopTarget - scorePopScale) * scorePopSpeed;

    // Helper to draw glowing text with scaling and customizable colors
    function drawGlowText(text, x, y, options = {}) {
      const scale = options.scale || 1;
      const fill = options.fillStyle || "white";
      const glow = options.glowColor || "cyan";
      const strokeCol = options.strokeColor || "black";
      const lineW = options.lineWidth || baseFontSize * 0.18;
      const blur = options.shadowBlur || baseFontSize * 0.55;
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      ctx.translate(-x, -y);
      ctx.lineWidth = lineW;
      ctx.strokeStyle = strokeCol;
      ctx.strokeText(text, x, y);
      ctx.shadowColor = glow;
      ctx.shadowBlur = blur;
      ctx.fillStyle = fill;
      ctx.fillText(text, x, y);
      ctx.restore();
    }

    // --------- Draw score (left) with pop and combo rainbow ---------
    const scoreX = rect.left + rect.width * 0.01;
    const scoreY = rect.top + rect.height * 0.55;
    if (now < rainbowEffectEnd) {
      // Dynamic rainbow hue cycling
      const hue = ((now / 10) % 360);
      const color = `hsl(${hue},100%,60%)`;
      drawGlowText(
        score.toString(),
        scoreX,
        scoreY,
        {
          scale: scorePopScale,
          fillStyle: color,
          glowColor: color,
          lineWidth: baseFontSize * 0.18,
          shadowBlur: baseFontSize * 0.7
        }
      );
    } else {
      drawGlowText(
        score.toString(),
        scoreX,
        scoreY,
        {
          scale: scorePopScale,
          fillStyle: "white",
          glowColor: "cyan"
        }
      );
    }

    // --------- Draw EdgeCoin counter (center) with flash ---------
    const edgeX = rect.left + rect.width * 0.65;
    const edgeY = rect.top + rect.height * 0.55;
    // Determine flash strength (0 to 1)
    let ecStrength = 0;
    if (edgeCoinFlashEnd > now) {
      ecStrength = Math.max(0, Math.min(1, (edgeCoinFlashEnd - now) / 1000));
    }
    // Adjust blur based on flash strength
    const edgeShadow = baseFontSize * (0.70 + 1.8 * ecStrength);
    ctx.save();
    ctx.lineWidth = baseFontSize * 0.20;
    ctx.strokeStyle = "black";
    ctx.strokeText(`${edgeCoinCollectedCount}/${GOAL_COUNT}`, edgeX, edgeY);
    ctx.shadowColor = "#00ff99";
    ctx.shadowBlur = edgeShadow;
    ctx.fillStyle = "#00ff55";
    ctx.fillText(`${edgeCoinCollectedCount}/${GOAL_COUNT}`, edgeX, edgeY);
    ctx.restore();

    // --------- Draw lives (right) with shake ---------
    const lifeBaseX = rect.left + rect.width * 1.40;
    const lifeY = rect.top + rect.height * 0.55;
    let shakeX = 0;
    if (lifeShakeEnd > now) {
      const remaining = lifeShakeEnd - now;
      const duration = 350; // ms
      const progress = Math.max(0, 1 - remaining / duration);
      // Oscillate and dampen
      shakeX = lifeShakeAmplitude * Math.sin(progress * Math.PI * 6) * (1 - progress);
    }
    drawGlowText(
      lives.toString(),
      lifeBaseX + shakeX,
      lifeY,
      {
        scale: 1.0,
        fillStyle: "white",
        glowColor: "cyan"
      }
    );

    // --------- Pulsing outline for the score bar ---------
    const pulsePeriod = 2000; // ms
    const phase = (now % pulsePeriod) / pulsePeriod;
    let pulseAlpha;
    if (phase < 0.5) {
      pulseAlpha = (phase / 0.5) * 0.25;
    } else {
      pulseAlpha = ((1 - phase) / 0.5) * 0.25;
    }
    pulseAlpha = 0;

    ctx.save();
    ctx.lineWidth = baseFontSize * 0.12;
    ctx.strokeStyle = `rgba(0,255,255,${pulseAlpha.toFixed(3)})`;
    ctx.shadowColor = `rgba(0,255,255,${pulseAlpha.toFixed(3)})`;
    ctx.shadowBlur = baseFontSize * 1.2;
    ctx.strokeRect(rect.left, rect.top, rect.width, rect.height);
    ctx.restore();

    // â˜…â˜…â˜… EdgeCoin 10æšç›®ã¾ã§ã®100ç§’ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³è¡¨ç¤º â˜…â˜…â˜…
if (edgeCoinCollectedCount === 9 && edgeCountdownEndTime) {
    const now = performance.now();
    let remaining = Math.max(0, Math.floor((edgeCountdownEndTime - now) / 1000));

    ctx.save();

    // åŸºæœ¬ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š
    ctx.font = `900 ${canvas.height * 0.05}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.lineWidth = 6;

    // ===== é€šå¸¸ã‚«ãƒ©ãƒ¼ï¼ˆ11ç§’ä»¥ä¸Šï¼‰ =====
    let fill = "yellow";
    let stroke = "black";
    let shadow = "rgba(0,0,0,0.8)";
    let blur = canvas.height * 0.01;

    // ===== â˜… ãƒ©ã‚¹ãƒˆ10ç§’ã§å…‰é‡ã‚¢ãƒƒãƒ—ï¼‹ç‚¹æ»… =====
    if (remaining <= 10) {
        // ç‚¹æ»…ï¼ˆé€Ÿã•ï¼š200mså‘¨æœŸï¼‰
        const flash = Math.floor(now / 200) % 2 === 0;

        fill = flash ? "white" : "yellow";
        stroke = flash ? "red" : "black";

        // å…‰é‡ï¼ˆã‚·ãƒ£ãƒ‰ã‚¦ï¼‰å¼·çƒˆã«
        shadow = "rgba(255, 80, 80, 1)";
        blur = canvas.height * 0.06;
    }

    // ===== åæ˜  =====
    ctx.fillStyle = fill;
    ctx.strokeStyle = stroke;
    ctx.shadowColor = shadow;
    ctx.shadowBlur = blur;

    // ===== æç”» =====
    ctx.strokeText(`NEXT EDGE: ${remaining}s`, canvas.width / 2, canvas.height * 0.15);
    ctx.fillText(`NEXT EDGE: ${remaining}s`, canvas.width / 2, canvas.height * 0.15);

    ctx.restore();
}




    ctx.restore();
}


function drawObstacle(ob, timestamp) {
  const oscillation = Math.sin((timestamp / 1000) * 2 + ob.phase) * ob.amplitude;
  const gapY = ob.baseGapY + oscillation;
  const gapHeight = ob.gapHeight;
  const topBodyHeight = gapY;
  const wickTopHeight = topBodyHeight * ob.wickTopRatio; 
  const bottomBodyY = gapY + gapHeight;
  const bottomBodyHeight = canvas.height - bottomBodyY;
  const wickBottomHeight = bottomBodyHeight * ob.wickBottomRatio;

  // ---- Rich candle drawing ----
  // Draw top (red) body with gradient, shadow and border
  ctx.save();
  const gradTop = ctx.createLinearGradient(ob.x, 0, ob.x, topBodyHeight);
  gradTop.addColorStop(0, '#e44a4a');
  gradTop.addColorStop(1, '#ff8f8f');
  ctx.fillStyle = gradTop;
  ctx.shadowColor = 'rgba(0,0,0,0.3)';
  ctx.shadowBlur = 4;
  ctx.fillRect(ob.x, 0, ob.width, topBodyHeight);
  ctx.shadowBlur = 0;
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.strokeRect(ob.x, 0, ob.width, topBodyHeight);
  ctx.restore();

  // Draw bottom (green) body with gradient, shadow and border
  ctx.save();
  const gradBot = ctx.createLinearGradient(ob.x, bottomBodyY, ob.x, bottomBodyY + bottomBodyHeight);
  gradBot.addColorStop(0, '#2ca24c');
  gradBot.addColorStop(1, '#6aff8a');
  ctx.fillStyle = gradBot;
  ctx.shadowColor = 'rgba(0,0,0,0.3)';
  ctx.shadowBlur = 4;
  ctx.fillRect(ob.x, bottomBodyY, ob.width, bottomBodyHeight);
  ctx.shadowBlur = 0;
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.strokeRect(ob.x, bottomBodyY, ob.width, bottomBodyHeight);
  ctx.restore();

  // Draw top wick (thinner and brighter)
  ctx.save();
  {
    const wickWidthTop = ob.width * 0.06;
    const topWickColor = lightenColor('#e44a4a', 0.4);
    ctx.fillStyle = topWickColor;
    ctx.fillRect(
      ob.x + (ob.width - wickWidthTop) / 2,
      topBodyHeight,
      wickWidthTop,
      wickTopHeight
    );
  }
  ctx.restore();

  // Draw bottom wick (thinner and brighter)
  ctx.save();
  {
    const wickWidthBottom = ob.width * 0.06;
    const bottomWickColor = lightenColor('#2ca24c', 0.4);
    ctx.fillStyle = bottomWickColor;
    ctx.fillRect(
      ob.x + (ob.width - wickWidthBottom) / 2,
      bottomBodyY - wickBottomHeight,
      wickWidthBottom,
      wickBottomHeight
    );
  }
  ctx.restore();
}

function checkCollision(ob, timestamp) {
  if (isDebugMode) {
      return false;
  }
  
  if (maru.y - maru.radius > canvas.height) {
    lives = 0; 
    endGame(); 
    return true;
  }

  const oscillation = Math.sin((timestamp / 1000) * 2 + ob.phase) * ob.amplitude;
  const gapY = ob.baseGapY + oscillation;
  const gapHeight = ob.gapHeight;
  const maruWidth = maru.radius * 2;
  const maruHeight = maru.radius * 2;
  const hbWidth = maruWidth * 0.2;
  const hbHeight = maruHeight * 0.8;
  const hbX = maru.x - (hbWidth / 2) + maruWidth * 0.10;
  const hbY = maru.y - maru.radius + maruHeight * 0.10;
  const maruRect = { x: hbX, y: hbY, w: hbWidth, h: hbHeight };

  let collision = false;
  if (maruRect.x + maruRect.w > ob.x && maruRect.x < ob.x + ob.width) {
    if (maruRect.y < gapY || maruRect.y + maruRect.h > gapY + gapHeight) {
      collision = true;
    }
  }
  
  if (collision && !isInvincible) {
    lives -= 1; 
    // Trigger life shake animation on life loss
    triggerLifeShake();
    updateLivesDisplay(); 
    
    if (lives <= 0) {
      endGame();
      return true;
    } else {
      hitSound.currentTime = 0;
      hitSound.play();
      
      isInvincible = true;
      invincibilityEndTime = timestamp + INVINCIBILITY_DURATION;
      
      const isFileProtocol = window.location.protocol === 'file:' || window.location.protocol === '';
      if (bgm && !isFileProtocol && bgm.paused && bgm.getAttribute('src')) {
         bgm.play().catch(e => console.error("BGM resume failed after hit:", e));
      }
      
      return true; 
    }
  }
  
  return false;
}

function drawMaru(timestamp) {
  const maruSize = maru.radius * 2;
  let imageToDraw = maru.currentImage;
  let flashing = false;
  
  if (isInvincible) {
    if (timestamp > invincibilityEndTime) {
      isInvincible = false;
    } else {
      const flashRate = 100;
      if (Math.floor(timestamp / flashRate) % 2 === 0) {
        flashing = true; 
      }
    }
  }

  if (flashing) {
    return; 
  }
  
  if (gameState === 'playing' || gameState === 'start') {
      if (timestamp - lastIdleSwitch > idleFrameInterval) {
        idleFrameIndex = (idleFrameIndex + 1) % maruIdleFrames.length;
        lastIdleSwitch = timestamp;
      }
      
      if (maru.vy < 0) {
        imageToDraw = images.maruJumpImg;
      } else {
        imageToDraw = maruIdleFrames[idleFrameIndex];
      }
  } 
  
  ctx.drawImage(imageToDraw, maru.x - maru.radius, maru.y - maru.radius, maruSize, maruSize);
  // Apply flash overlay when maruFlashEnd is active
  if (maruFlashEnd > timestamp) {
    const progress = (maruFlashEnd - timestamp) / 300;
    ctx.save();
    const grd = ctx.createRadialGradient(maru.x, maru.y, 0, maru.x, maru.y, maru.radius);
    const alpha = Math.max(0, progress);
    grd.addColorStop(0, `rgba(255,255,255,${alpha * 0.8})`);
    grd.addColorStop(1, `rgba(0,255,128,0)`);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(maru.x, maru.y, maru.radius * 1.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}


let lastTimestamp = null;
let animFrameId = null;

// Audio setup and other supporting functions are the same as before, ensuring game logic continuity.
function setupAudio() {
  if (!audioCtx) {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const isFilePage = window.location.protocol === 'file:' || window.location.protocol === '';
      const srcAttr = bgm ? bgm.getAttribute('src') : null;
      const isRemoteSrc = srcAttr && /^https?:\/\//i.test(srcAttr);
      const useAnalyser = !isFilePage || (isFilePage && isRemoteSrc);
      
      if (useAnalyser) {
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 64;
        const source = audioCtx.createMediaElementSource(bgm);
        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        frequencyData = new Uint8Array(analyser.frequencyBinCount);
      } else {
        analyser = null;
        frequencyData = null;
      }
    } catch (e) {
      console.warn('Web Audio API initialisation failed:', e);
      analyser = null;
      frequencyData = null;
    }
  }
}
function initStars() {
  stars = [];
  const density = 1 / 8000;
  const numStars = Math.floor(canvas.width * canvas.height * density);
  for (let i = 0; i < numStars; i++) {
    stars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * 0.8,
      size: Math.random() * 1.5 + 0.5,
      speed: Math.random() * 0.3 + 0.1,
      baseBrightness: Math.random() * 0.5 + 0.2,
      twinkleSpeed: Math.random() * 0.04 + 0.01,
      twinklePhase: Math.random() * Math.PI * 2
    });
  }
}
function updateStars(delta) {
  const dt = delta / FRAME_TIME;
  for (const star of stars) {
    star.x -= star.speed * dt;
    if (star.x < -star.size) {
      star.x += canvas.width + star.size;
      star.y = Math.random() * canvas.height * 0.8;
    }
  }
}
function drawStars(timestamp) {
  ctx.save();
  for (const star of stars) {
    const twinkle = 0.4 * Math.sin((timestamp * star.twinkleSpeed) + star.twinklePhase);
    // Additional brightness when a score event occurs
    let extra = 0;
    if (starFlashEnd > timestamp) {
      const remaining = starFlashEnd - timestamp;
      extra = Math.max(0, Math.min(0.5, (remaining / 500) * 0.5));
    }
    let alpha = star.baseBrightness + twinkle + extra;
    if (alpha > 1) alpha = 1;
    ctx.fillStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;
    ctx.beginPath();
    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}
function drawEqualizer() {
    if (!analyser || !frequencyData) return;

    analyser.getByteFrequencyData(frequencyData);

    const barCount = 32;   // è¡¨ç¤ºãƒãƒ¼æ•°
    const barWidth = canvas.width / (barCount * 1.5);
    const startX = canvas.width * 0.1;
    const baseY = canvas.height * 0.96;

    for (let i = 0; i < barCount; i++) {
        const value = frequencyData[i];  
        const barHeight = (value / 255) * (canvas.height * 0.25);

        ctx.save();
        ctx.fillStyle = `rgba(${100 + value}, 50, 255, 0.8)`;  
        ctx.shadowBlur = 20;
        ctx.shadowColor = "cyan";
        ctx.fillRect(
            startX + i * barWidth * 1.5,
            baseY - barHeight,
            barWidth,
            barHeight
        );
        ctx.restore();
    }
}
function drawBackground(timestamp) {

  // --- èƒŒæ™¯ã‚°ãƒ©ãƒ‡ï¼ˆä¸­å¤®æ˜ã‚‹ã„ â†’ å¤–å´æš—ã„ï¼‰---
  const radGrad = ctx.createRadialGradient(
    canvas.width / 2,
    canvas.height * 0.8,
    0,
    canvas.width / 2,
    canvas.height * 0.8,
    canvas.height
  );
  radGrad.addColorStop(0, '#1e5fff');
  radGrad.addColorStop(0.4, '#153054');
  radGrad.addColorStop(1, '#060b18');

  ctx.fillStyle = radGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // --- æ˜Ÿ ---
  drawStars(timestamp);

  // --- æ³¢ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ ---
  const baseY = canvas.height * 0.75;
  const waveLength = canvas.width * 0.5;

  // â˜… å‰ã«é€²ã‚€æ³¢ã‚ªãƒ•ã‚»ãƒƒãƒˆ
  if (typeof drawBackground.waveShift === "undefined") {
      drawBackground.waveShift = 0;
  }
  drawBackground.waveShift += 0.6;
  const offset1 = drawBackground.waveShift;

  // === 1ã¤ç›®ã®æ³¢ï¼ˆå¥¥ï¼‰ ===
  ctx.save();
  ctx.fillStyle = 'rgba(20, 63, 107, 0.9)';
  ctx.beginPath();
  ctx.moveTo(0, baseY);
  for (let x = 0; x <= canvas.width; x += 4) {
      const y = baseY + canvas.height * 0.04 *
          Math.sin((x + offset1) * 2 * Math.PI / waveLength);
      ctx.lineTo(x, y);
  }
  ctx.lineTo(canvas.width, canvas.height);
  ctx.lineTo(0, canvas.height);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // === è›å…‰ã®æ³¢ãƒ©ã‚¤ãƒ³ ===
  ctx.save();
  ctx.strokeStyle = 'rgba(0,255,255,0.6)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let x = 0; x <= canvas.width; x += 4) {
      const y = baseY + canvas.height * 0.04 *
          Math.sin((x + offset1) * 2 * Math.PI / waveLength);
      if (x === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
  }
  ctx.stroke();
  ctx.restore();

  // === 2ã¤ç›®ã®æ³¢ï¼ˆæ‰‹å‰ï¼‰ ===
  const offset2 = offset1 * 1.2;

  ctx.save();
  ctx.fillStyle = 'rgba(14, 46, 82, 0.9)';
  ctx.beginPath();
  ctx.moveTo(0, baseY + canvas.height * 0.04);

  for (let x = 0; x <= canvas.width; x += 4) {
      const y = baseY + canvas.height * 0.04 +
          canvas.height * 0.025 *
          Math.sin((x + offset2) * 2 * Math.PI / waveLength);
      ctx.lineTo(x, y);
  }

  ctx.lineTo(canvas.width, canvas.height);
  ctx.lineTo(0, canvas.height);
  ctx.closePath();
  ctx.fill();
  ctx.restore();





}function updateMaru(delta, timestamp) {
  if (!hasStarted) return;
  const dt = delta / FRAME_TIME;
  maru.vy += GRAVITY * dt;
  maru.y += maru.vy * dt;
}
function updateObstacles(delta) {
  if (!hasStarted) return;
  const dt = delta / FRAME_TIME;

  const timeElapsed = gameStartTime === null ? 0 : performance.now() - gameStartTime;
  const speedScale = Math.min(1.0, timeElapsed / SPEED_SCALE_TIME); 
  const currentSpeed = canvas.width * (BASE_SPEED_PER_WIDTH + BASE_SPEED_PER_WIDTH * speedScale);
  
  const difficultyTime = 60000; 
  const difficultyFactor = Math.min(1, timeElapsed / difficultyTime); 
  const baseSpawnInterval = 2500;
  const minSpawnInterval = 700;
  spawnInterval = baseSpawnInterval - (baseSpawnInterval - minSpawnInterval) * difficultyFactor;
  
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const ob = obstacles[i];
    ob.x -= currentSpeed * dt;
    if (ob.x + ob.width < 0) {
      obstacles.splice(i, 1);
    }
  }

  if (performance.now() - lastSpawn > spawnInterval) {
    spawnObstacle(); 
    lastSpawn = performance.now();
  }
}

// gameLoop, endGame, showInfo function are the same as before


function gameLoop(timestamp) {
  
 if (gameState !== 'playing') {
    // video ã®ã¨ãã ã‘ãƒ«ãƒ¼ãƒ—ã‚’æ­¢ã‚ã‚‹
    if (gameState === 'video' || gameState === 'ending_trigger') return;
}

  if (lastTimestamp === null) {
    lastTimestamp = timestamp;
  }
  const delta = timestamp - lastTimestamp;
  lastTimestamp = timestamp;

  updateStars(delta);
  updateMaru(delta, timestamp);
  // Update afterimages after maru moves
  updateAfterimages(delta);
  updateObstacles(delta);
  updateCoins(delta);
  // Update particle effects after coin updates
  updateParticles(delta);
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBackground(timestamp);
 
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const ob = obstacles[i];
    drawObstacle(ob, timestamp);
    if (gameState === 'playing') {
      checkCollision(ob, timestamp); 
      // â­ ã€ä¿®æ­£ã€‘è¡çªãƒã‚§ãƒƒã‚¯å¾Œã€ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ç§»è¡Œãƒã‚§ãƒƒã‚¯ã‚’ã—ãªã„
    }
    
    if (!ob.passed && ob.x + ob.width < maru.x - maru.radius) {
      ob.passed = true;
      score += 1;
      // Trigger score increase effects when passing an obstacle
      triggerScoreIncrease(1, maru.x, maru.y);
    }
  }
  
  // Draw particles behind coins and maru
  drawParticles();
  // Draw afterimages behind Maru
  drawAfterimages();
  drawMaru(timestamp);
  drawCoins(delta);
  drawEqualizer();   
  
  if (gameState === 'playing') {
    checkCoinCollision();
    // â­ ã€ä¿®æ­£ã€‘ã‚³ã‚¤ãƒ³è¡çªãƒã‚§ãƒƒã‚¯å¾Œã€ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ç§»è¡Œãƒã‚§ãƒƒã‚¯ã‚’ã—ãªã„
  }
  
 
  if (nextMessageIndex < messages.length && score >= messages[nextMessageIndex].threshold) {
    showInfo(messages[nextMessageIndex].text);
    nextMessageIndex++;
  }
  
  // â˜…â˜…â˜…â˜…â˜… ã“ã“ã«è¿½åŠ ï¼ â˜…â˜…â˜…â˜…â˜…
  drawScoreBoard();
  // â˜…â˜…â˜…â˜…â˜… ã“ã“ã«è¿½åŠ ï¼ â˜…â˜…â˜…â˜…â˜…

  
  if (gameState === 'playing') {
    animFrameId = window.requestAnimationFrame(gameLoop);
  }
}




function initBGM() {
    // AudioContext åˆæœŸåŒ–ï¼ˆ2å›ç›®ä»¥é™ã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 64;  // EQ ã®è§£åƒåº¦
        frequencyData = new Uint8Array(analyser.frequencyBinCount);
    }

    const bgm = document.getElementById("bgm");
    if (!bgm) return;

    const source = audioCtx.createMediaElementSource(bgm);

    source.connect(analyser);
    analyser.connect(audioCtx.destination);

    // å†ç”Ÿ
    bgm.currentTime = 0;
    bgm.play();
}



function endGame() {
  if (gameState !== 'playing') return; 
  gameState = 'gameover';
  
  if (animFrameId !== null) {
    cancelAnimationFrame(animFrameId);
    animFrameId = null;
  }
  
  maru.currentImage = images.maruYarareImg; 
  
  const finalTimestamp = performance.now();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBackground(finalTimestamp);
  
  hitSound.currentTime = 0;
  hitSound.play();
  
  if (score > bestScore) bestScore = score;
  
  // ğŸŒŸ ä¿®æ­£: æœ€çµ‚ã‚¹ã‚³ã‚¢è¡¨ç¤ºã« EdgeXã‚³ã‚¤ãƒ³åé›†æ•°ã‚’å«ã‚ã‚‹
  finalScoreElem.innerHTML = `ã‚¹ã‚³ã‚¢: <strong>${score}</strong><br>ãƒ™ã‚¹ãƒˆã‚¹ã‚³ã‚¢: <strong>${bestScore}</strong><br>EDGEXã‚³ã‚¤ãƒ³åé›†æ•°: <strong>${edgeCoinCollectedCount}/${GOAL_COUNT}</strong>`;
  
  const tweetText = encodeURIComponent(`I played #MARUWAVEX.\n#edgeX\nSCORE: ${score}\nEdgeCoin ${edgeCoinCollectedCount}/${GOAL_COUNT}\n`
);
  const url = encodeURIComponent("URLå¾Œæ—¥è¿½åŠ ");
  tweetButton.href = `https://twitter.com/intent/tweet?text=${tweetText}&hashtags=MARUWAVEX&url=${url}`;

  gameOverMsg.style.display = 'flex';
  overlay.style.pointerEvents = 'auto';
  // ğŸŒŸ ä¿®æ­£: ã‚¹ã‚³ã‚¢è¡¨ç¤ºã‚’éè¡¨ç¤ºã«ã™ã‚‹å¿…è¦ãŒãªã„ãŸã‚ã€ç©ºã«ã—ãªã„
  
  if (bgm) {
    bgm.pause();
    bgm.currentTime = 0;
  }
}


function showInfo(text) {
  infoMsg.textContent = text;
  infoMsg.style.display = 'block';
  setTimeout(() => {
    infoMsg.style.display = 'none';
  }, 2000);
}

// ---------------------------------------------------------------------------
// ğŸ†âœ¨ Additional helper functions for rich visual effects
// These functions implement particle systems, afterimages, combo effects,
// edge coin flashes, life shaking, and star pulsing. They are called from
// various game logic locations to trigger and update the animations.
// ---------------------------------------------------------------------------

// Trigger a generic score increase. Handles pop scale, combo streak and star flash.
function triggerScoreIncrease(amount, x, y) {
  // Start the pop animation
  scorePopScale = 1.4;
  scorePopTarget = 1.0;
  // Determine combo streak
  const now = performance.now();
  if (now - lastScoreUpdateTime < 800) {
    scoreStreakCount++;
  } else {
    scoreStreakCount = 1;
  }
  lastScoreUpdateTime = now;
  if (scoreStreakCount >= 3) {
    // Activate rainbow effect for 1 second
    rainbowEffectEnd = now + 1000;
  }
  // Briefly brighten the stars
  starFlashEnd = now + 500;
  // Spawn a small particle burst at the provided location if supplied
  if (typeof x === 'number' && typeof y === 'number') {
    spawnParticleBurst(x, y, false);
  }
}

// Trigger special effects for collecting an EdgeCoin
function triggerEdgeCoinEffects(x, y) {
  const now = performance.now();
  // Flash the central counter for 1 second
  edgeCoinFlashEnd = now + 1000;
  // Flash the maru character for 0.3 seconds
  maruFlashEnd = now + 300;
  // Brighten the stars a bit longer
  starFlashEnd = now + 700;
  // Spawn a larger particle burst with edge colors
  if (typeof x === 'number' && typeof y === 'number') {
    spawnParticleBurst(x, y, true);
  }
}

// Spawn a burst of particles at (x, y). If isEdge is true, use green palette.
function spawnParticleBurst(x, y, isEdge) {
  const count = isEdge ? 15 : 10;
  const radius = isEdge ? 40 : 20;
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = (Math.random() * 0.4 + 0.6) * radius;
    const sx = Math.cos(angle) * speed;
    const sy = Math.sin(angle) * speed;
    particles.push({
      x: x,
      y: y,
      vx: sx,
      vy: sy,
      age: 0,
      life: 0.4,
      size: isEdge ? 6 : 4,
      startColor: isEdge ? { r: 0, g: 255, b: 153 } : { r: 255, g: 215, b: 0 },
      endColor: isEdge ? { r: 0, g: 102, b: 68 } : { r: 255, g: 127, b: 0 }
    });
  }
}

// Update all particles
function updateParticles(delta) {
  const dt = delta / 1000;
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.age += dt;
    // Apply slight deceleration
    p.vx *= 0.98;
    p.vy *= 0.98;
    if (p.age > p.life) {
      particles.splice(i, 1);
    }
  }
}

// Draw all particles
function drawParticles() {
  for (const p of particles) {
    const t = p.age / p.life;
    const r = p.startColor.r + (p.endColor.r - p.startColor.r) * t;
    const g = p.startColor.g + (p.endColor.g - p.startColor.g) * t;
    const b = p.startColor.b + (p.endColor.b - p.startColor.b) * t;
    const alpha = 1 - t;
    const size = p.size * (1 - t * 0.5);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = `rgb(${Math.round(r)},${Math.round(g)},${Math.round(b)})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// Trigger shake animation for life counter
function triggerLifeShake() {
  lifeShakeEnd = performance.now() + 350; // duration in ms
  lifeShakeAmplitude = 8 + Math.random() * 4;
}

// Spawn afterimages when Maru jumps
function spawnAfterimages() {
  const count = 1 + Math.floor(Math.random() * 2);
  for (let i = 0; i < count; i++) {
    afterimages.push({
      x: maru.x,
      y: maru.y,
      radius: maru.radius,
      image: maru.currentImage,
      startTime: performance.now(),
      life: 250
    });
  }
}

// Update afterimages (remove old ones)
function updateAfterimages(delta) {
  const now = performance.now();
  for (let i = afterimages.length - 1; i >= 0; i--) {
    const ai = afterimages[i];
    if (now - ai.startTime > ai.life) {
      afterimages.splice(i, 1);
    }
  }
}

// Draw afterimages behind Maru
function drawAfterimages() {
  const now = performance.now();
  for (const ai of afterimages) {
    const progress = (now - ai.startTime) / ai.life;
    const alpha = Math.max(0, 1 - progress);
    const scale = 1 + progress * 0.2;
    ctx.save();
    ctx.globalAlpha = alpha * 0.5;
    const size = ai.radius * 2 * scale;
    ctx.drawImage(ai.image, ai.x - ai.radius * scale, ai.y - ai.radius * scale, size, size);
    ctx.restore();
  }
}





function preloadImages() {
    return new Promise((resolve) => {
        let loadedCount = 0;
        // ä¿®æ­£: sealLifeImgã‚’ã‚«ã‚¦ãƒ³ãƒˆã‹ã‚‰é™¤å¤–ï¼ˆHTMLå†…ã®å‚ç…§ã¯ãã®ã¾ã¾ï¼‰
        const totalCount = Object.keys(imageSources).length - 1; 
        
        // å¤–éƒ¨ç”»åƒï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼/ã‚¹ã‚³ã‚¢ãƒãƒ¼ï¼‰ã‚’å«ã‚ã¦ã‚«ã‚¦ãƒ³ãƒˆ
        const totalImages = totalCount + 3; 

        if (totalImages === 0) {
            resolve();
            return;
        }

        const imageLoaded = () => {
            loadedCount++;
            if (loadedCount === totalImages) {
                resolve();
            }
        };

        // å†…éƒ¨ã‚²ãƒ¼ãƒ ç”»åƒ
        for (const key in imageSources) {
            // sealLifeImg ã¯ã‚«ã‚¦ãƒ³ãƒˆã—ãªã„
            if (key === 'sealLifeImg') continue;

            const img = images[key];
            if (img.complete) {
                imageLoaded();
            } else {
                img.onload = imageLoaded;
                img.onerror = () => {
                    console.warn(`Failed to load image: ${imageSources[key]}.`);
                    imageLoaded(); 
                };
            }
        }
        
        // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ç”»åƒï¼ˆHTMLã‚¿ã‚°ã§å‚ç…§ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ï¼‰
        const startImgElement = document.getElementById('startImage');

        if (startImgElement) {
            startImgElement.onload = imageLoaded;
            startImgElement.onerror = imageLoaded;
        } else {
            imageLoaded();
        }

        
        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ç”»åƒï¼ˆHTMLã‚¿ã‚°ã§å‚ç…§ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ï¼‰
        const gameOverImg = document.getElementById('gameOverImage');
        if (gameOverImg) {
            gameOverImg.onload = imageLoaded;
            gameOverImg.onerror = imageLoaded; 
        } else {
            imageLoaded();
        }
        
        // ã‚¹ã‚³ã‚¢ãƒãƒ¼ç”»åƒï¼ˆHTMLã‚¿ã‚°ã§å‚ç…§ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ï¼‰
        const scoreBarImg = document.getElementById('scoreBarImage');
        if (scoreBarImg) {
            scoreBarImg.onload = imageLoaded;
            scoreBarImg.onerror = imageLoaded; 
        } else {
            imageLoaded();
        }
        
        // sealLifeImg ã¯å‹•çš„è¡¨ç¤ºã«åˆ©ç”¨ã—ãªã„ãŒã€imgã‚¿ã‚°ãŒå­˜åœ¨ã™ã‚‹ãŸã‚ã€ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆã‹ã‚‰é™¤å¤–
        
    });
}

// Event listeners
function handleGameInput(e) {
    if (e.target.closest('#restartButton') ||
        e.target.closest('#tweetButton') ||
        e.target.closest('#skipButton') ||
        e.target.closest('#startButton') || // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã¯å«ã‚ãªã„
        e.target.closest('#debugButton')) {
        return;
    }
    
    if (gameState === 'playing' || gameState === 'start') {
        jump();
    } 
    
    if (e.type === 'touchstart') {
        e.preventDefault(); 
    }
}

// -------------------------------
// ğŸ”¥ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ã«ã‚ˆã‚‹ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ï¼‰
// -------------------------------
document.addEventListener('keydown', (e) => {
    // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ (keyCode 32) ã¾ãŸã¯ (key ' ' / 'Spacebar') ã®å ´åˆ
    if (e.code === 'Space' || e.keyCode === 32) {
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‹•ä½œãªã©ã‚’é˜²ã
        e.preventDefault(); 
        
        if (gameState === 'playing' || gameState === 'start') {
            jump();
        }
    }
});

document.addEventListener('mousedown', handleGameInput);
document.addEventListener('touchstart', handleGameInput);

skipButton.addEventListener('click', skipVideo);
skipButton.addEventListener('touchstart', (e) => {
    e.preventDefault(); 
    skipVideo();
});

document.addEventListener('contextmenu', function(e) {
  e.preventDefault();
});

// -------------------------------
// ğŸ”¥ ãƒ‡ãƒãƒƒã‚°ãƒœã‚¿ãƒ³ 10é€£ã‚¿ãƒƒãƒ—ã§èµ·å‹•
// -------------------------------
let debugTapCount = 0;
let debugTapTimer = null;

debugButton.addEventListener("click", () => {
    debugTapCount++;

    // 60ç§’ä»¥å†…ã«105ã‚¿ãƒƒãƒ—å¿…è¦
    if (!debugTapTimer) {
        debugTapTimer = setTimeout(() => {
            debugTapCount = 0;
            debugTapTimer = null;
        }, 60000);
    }

    if (debugTapCount >= 77) {
        clearTimeout(debugTapTimer);
        debugTapTimer = null;
        debugTapCount = 0;

        console.log("DEBUG MODE UNLOCKED");
        initGame(true); // â† ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰èµ·å‹•
        // â­ ã€è¿½åŠ ã€‘ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰èµ·å‹•æ™‚ã«EdgeCoin 100%ã‚¹ã‚¤ãƒƒãƒã‚’ONã«ã™ã‚‹
        forceEdgeCoin100 = true;
        showInfo('DEBUG: EdgeCoin 100% ON');
    }
});





// ğŸŒŸ åˆæœŸåŒ–
preloadImages().then(() => {
    // ğŸŒŸ ç”»åƒãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
    document.getElementById('startButton').addEventListener('click', () => {
    initBGM();         // â† è¿½åŠ ï¼ˆã“ã‚ŒãŒã‚¤ã‚³ãƒ©ã‚¤ã‚¶ãƒ¼ã«çµ¶å¯¾å¿…è¦ï¼‰
    initGame(false);
});
    restartButton.addEventListener('click', () => {
      initGame(isDebugMode);
    });
    
    resize();
    drawBackground(performance.now());
    drawMaru(performance.now()); 
    
});
   // -------------------------------------------------
// â­ ã€å®Œå…¨ç‰ˆã€‘ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚·ãƒ¼ã‚±ãƒ³ã‚¹
// -------------------------------------------------
function startEndingSequence() {
    skipButton.style.display = 'none';

    // -----------------------------------------
    // â­ BGMåœæ­¢ï¼ˆå¿µã®ãŸã‚ç¢ºå®Ÿã«æ­¢ã‚ã‚‹ï¼‰
    // -----------------------------------------
    if (bgm) {
        try {
            bgm.pause();
            bgm.currentTime = 0;
        } catch (e) {
            console.error("Failed to stop BGM:", e);
        }
    }

    // -----------------------------------------
    // â­ â‘  ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°å‹•ç”»ï¼ˆend.mp4ï¼‰ã‚’å†ç”Ÿ
    //     â€»ã“ã®å‹•ç”»ã¯ã€Œ1æœ¬åŒ–ã•ã‚Œã¦ã„ã‚‹ã€å‰æ
    // -----------------------------------------
    playVideoDirect("movies/end.mp4", () => {
        // â€»çµ‚äº†å¾Œã«ä½•ã‹ã™ã‚‹å¿…è¦ã¯ãªã„
    });

    // -----------------------------------------
    // â­ â‘¡ 5.5ç§’å¾Œã« ending.mp3 ã‚’å†ç”Ÿ
    // -----------------------------------------
    setTimeout(() => {
        try {
            const endingBgm = new Audio("sounds/bgm/ending.mp3");
            endingBgm.volume = 1.0;
            endingBgm.play().catch(e => console.error("ending.mp3 play failed:", e));
        } catch (e) {
            console.error("Failed to play ending.mp3:", e);
        }
    }, 5500);


    // -----------------------------------------
    // â­ â‘¢ end.mp4 ã®é•·ã•ã«åˆã‚ã›ã¦ã€
    //     å‹•ç”»çµ‚äº†å¾Œã«ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°çµæœUIã‚’å‡ºã™
    //
    // ğŸ”¥é‡è¦ï¼š
    //  end.mp4 ã®é•·ã•ãŒã€Œç´„10ç§’ã€å‰æãªã‚‰ 10000ms å¾Œã«å®Ÿè¡Œ
    //  å¿…è¦ãªã‚‰ã‚ãªãŸã® end.mp4 ã®ç§’æ•°ã«åˆã‚ã›ã¦èª¿æ•´ã§ãã‚‹
    // -----------------------------------------
    const ENDING_VIDEO_DURATION = 20000; // â†å¿…è¦ãªã‚‰èª¿æ•´

    setTimeout(() => {
        showEndingResultUI();
    }, ENDING_VIDEO_DURATION);

}

function showEndingResultUI() {

    // 1) çµæœè¡¨ç¤ºã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
    const overlay = document.createElement("div");
    overlay.id = "endingResultOverlay";
    overlay.style.position = "absolute";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.background = "rgba(0,0,0,0.75)";
    overlay.style.display = "flex";
    overlay.style.flexDirection = "column";
    overlay.style.justifyContent = "center";
    overlay.style.alignItems = "center";
    overlay.style.zIndex = "9999";
    overlay.style.textAlign = "center";

    // 2) ã‚¹ã‚³ã‚¢è¡¨ç¤ºï¼ˆæ–°ãƒ‡ã‚¶ã‚¤ãƒ³ï¼‰
    const scoreText = document.createElement("div");
    scoreText.innerHTML = `
        <div class="endingText">SCORE: ${score}</div>
        <div class="endingSub">EDGE COIN: ${edgeCoinCollectedCount}/${GOAL_COUNT}</div>
    `;
    overlay.appendChild(scoreText);

    // 3) Tweet ãƒœã‚¿ãƒ³ï¼ˆæ–°ãƒ‡ã‚¶ã‚¤ãƒ³ï¼‰
    const tweetBtn = document.createElement("a");
    tweetBtn.textContent = "Tweet";
    tweetBtn.className = "tweetBtn";   // â˜…â˜…â˜… CSSé©ç”¨ã®ãŸã‚çµ¶å¯¾å¿…è¦ â˜…â˜…â˜…

    tweetBtn.target = "_blank";
    tweetBtn.href =
        `https://twitter.com/intent/tweet?text=` +
        encodeURIComponent(
            `I cleared #MARUWAVEX.\n#edgeX\nSCORE: ${score}\nEdgeCoin ${edgeCoinCollectedCount}/${GOAL_COUNT}\n`
        );

    overlay.appendChild(tweetBtn);

    document.body.appendChild(overlay);
}



</script>
<!-- â˜…â˜…â˜… ã“ã“ã¾ã§ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°å°‚ç”¨ã‚³ãƒ¼ãƒ‰ å®Œå…¨ç‰ˆ â˜…â˜…â˜… -->
</body>
</html>